<!DOCTYPE html>
<html>
<head>
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Ch√∫c M·ª´ng Sinh Nh·∫≠t Thu·ª≥ D∆∞∆°ng</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
<style>
  body {
    background-color: pink;
    display: flex;
    flex-direction: column;
    justify-content: center;
    align-items: center;
    min-height: 100vh;
    margin: 0;
    text-align: center;
    overflow: hidden;
    position: relative;
    font-family: 'Inter', sans-serif; /* S·ª≠ d·ª•ng font Inter */
  }

  button {
    padding: 15px 30px;
    font-size: 16px;
    cursor: pointer;
    border: none;
    border-radius: 10px;
    background-color: white;
    color: black;
    font-weight: bold;
    background-image: linear-gradient(45deg, #FFDA63, #FF914D, #FF6363, #9400D3, #4B0082, #008080, #00BFFF, #8FBC8F);
    background-size: 400% 400%;
    animation: rainbow 5s infinite alternate;
    color: white;
    box-shadow: 5px 5px 10px rgba(0, 0, 0, 0.3);
    position: relative;
    overflow: hidden;
    transition: transform 0.2s ease-in-out; /* Gi·ªØ hi·ªáu ·ª©ng di chu·ªôt */
  }

  button:hover {
    transform: scale(1.05);
  }

  button::before {
    content: "";
    position: absolute;
    top: -20px;
    left: -20px;
    width: calc(100% + 40px);
    height: calc(100% + 40px);
    /* Placeholder for image - original URL was 'duong_dan_den_hinh_anh_hoa_la.png' */
    background-image: url('https://placehold.co/100x100/A0A0A0/FFFFFF?text=Floral+Pattern'); /* H√¨nh ·∫£nh placeholder */
    background-size: cover;
    opacity: 0.3;
    z-index: -1;
  }

  @keyframes rainbow {
    0% {
      background-position: 0% 50%;
    }
    100% {
      background-position: 100% 50%;
    }
  }

  #trang2 {
    display: none; /* Tr·ªü l·∫°i tr·∫°ng th√°i ban ƒë·∫ßu */
    margin-top: 20px;
    z-index: 10;
    position: relative;
  }

  /* C·ª° ch·ªØ responsive s·ª≠ d·ª•ng clamp() */
  #tieuDeSinhNhat {
    font-size: clamp(19px, 4.8vw, 40px);
    color: purple;
    font-weight: bold;
    margin-bottom: 15px;
    text-shadow: 3px 3px 5px rgba(0, 0, 0, 0.5);
  }

  #ngaySinh {
    font-size: clamp(13px, 3.2vw, 25px);
    color: blue;
    font-style: italic;
    margin-bottom: 15px;
    text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.3);
  }

  #loiKhen {
    font-size: clamp(10px, 2.5vw, 19px);
    color: #FF69B4;
    font-weight: bold;
    margin-bottom: 25px;
    text-shadow: 2px 2px 3px rgba(0, 0, 0, 0.3);
  }

  .loiChucSinhNhat {
    font-size: clamp(7px, 2.0vw, 16px);
    color: Brown;
    line-height: 1.6;
    margin-bottom: 12px;
    text-shadow: 1px 1px 2px rgba(0, 0, 0, 0.2);
  }

  #audioNen {
    display: none;
  }

  #animation-canvas { /* Canvas duy nh·∫•t cho t·∫•t c·∫£ ho·∫°t ·∫£nh */
    position: absolute;
    top: 0;
    left: 0;
    width: 100%;
    height: 100%;
    pointer-events: none;
    z-index: 5;
    will-change: transform, opacity;
  }
</style>
</head>
<body>

<button id="nutBatNgo">Nh·∫•n v√† s·∫Ω c√≥ b·∫•t ng·ªù!</button>

<div id="trang2">
  <h1 id="tieuDeSinhNhat">Ch√∫c M·ª´ng Sinh Nh·∫≠t Thu·ª≥ D∆∞∆°ng</h1>
  <p id="ngaySinh">Ng√†y 20 Th√°ng 6</p>
  <p id="loiKhen">ü©∑Ng√†y m√† m·ªôt thi√™n th·∫ßn d·ªÖ th∆∞∆°ng xinh ƒë·∫πp ƒë∆∞·ª£c sinh raü©∑</p>
  <p class="loiChucSinhNhat">ü•∞Ch√∫c em sinh nh·∫≠t vui v·∫ªü•∞</p>
  <p class="loiChucSinhNhat">‚ù§Ô∏èMong r·∫±ng tu·ªïi m·ªõi s·∫Ω mang ƒë·∫øn em th·∫≠t nhi·ªÅu ni·ªÅm vui v√† nh·ªØng ƒëi·ªÅu b·∫•t ng·ªù th√∫ v·ªã‚ù§Ô∏è.</p>
  <p class="loiChucSinhNhat">‚ù§Ô∏èCh√∫c em lu√¥n xinh ƒë·∫πp, r·∫°ng r·ª° nh∆∞ nh·ªØng ƒë√≥a hoa v√† ng·ªçt ng√†o nh∆∞ nh·ªØng vi√™n k·∫πo‚ù§Ô∏è.</p>
  <p class="loiChucSinhNhat">‚ù§Ô∏èCh√∫c em t∆∞∆°ng lai s·∫Ω c√≥ ng∆∞·ªùi lu√¥n y√™u th∆∞∆°ng em, chi·ªÅu tru·ªông em h·∫øt m·ª±c‚ù§Ô∏è.</p>
  <p class="loiChucSinhNhat">‚ù§Ô∏èCh√∫c em m√£i m√£i l√† n√†ng c√¥ng ch√∫a b√© nh·ªè c·ªßa ng∆∞·ªùi m√† em th∆∞∆°ng‚ù§Ô∏è.</p>
  <p class="loiChucSinhNhat">‚ù§Ô∏èCh√∫c em lu√¥n mai m·∫Øn trong cu·ªôc s·ªëng nh·ªØng ƒëi·ªÅu t·ªët nh·∫•t s·∫Ω ƒë·∫øn b√™n em‚ù§Ô∏è.</p>
  <p class="loiChucSinhNhat">‚ù§Ô∏èG·ª≠i ƒë·∫øn em nh·ªØng l·ªùi ch√∫c t·ªët ƒë·∫πp nh·∫•t t·ª´ tr√°i tim!‚ù§Ô∏è</p>
  <p class="loiChucSinhNhat">‚ù§Ô∏èCh√∫c em t·∫•t c·∫£‚ù§Ô∏è.</p>
</div>

<audio id="audioNen" src="birthday.mp3"></audio>

<canvas id="animation-canvas"></canvas>

<script>
// Canvas v√† context, ƒë·∫∑t to√†n c·ª•c ƒë·ªÉ d·ªÖ truy c·∫≠p trong v√≤ng l·∫∑p ho·∫°t ·∫£nh
let animationCanvas;
let ctx;
let requestId; // ƒê·ªÉ l∆∞u tr·ªØ ID requestAnimationFrame cho vi·ªác h·ªßy b·ªè ti·ªÅm nƒÉng

// M·∫£ng ch·ª©a c√°c ƒë·ªëi t∆∞·ª£ng ho·∫°t ·∫£nh
const particles = [];
const fireworks = [];
const stars = [];
const hearts = [];
const balloons = [];
const soapBubbles = []; // M·∫£ng cho bong b√≥ng x√† ph√≤ng
const paperCranes = []; // M·∫£ng cho h·∫°c gi·∫•y

// C√°c h·∫±ng s·ªë cho ho·∫°t ·∫£nh
const gravity = 0.05; // Tr·ªçng l·ª±c
const fireworkColors = ['#FFD700', '#FF4500', '#00FF7F', '#1E90FF', '#BA55D3', '#FF69B4', '#FFFFFF']; // M√†u ph√°o hoa s√°ng h∆°n
const starColors = ['red', 'orange', 'yellow', 'lime', 'blue', 'violet', 'white', 'gold', 'silver']; // M√†u sao ban ƒë·∫ßu
const heartColor = 'red'; // M√†u tr√°i tim ban ƒë·∫ßu
const balloonColors = ['red', 'green', 'blue', 'yellow', 'purple', 'orange', 'cyan', 'magenta']; // M√†u bong b√≥ng ban ƒë·∫ßu

// --- H√†m h·ªó tr·ª£ v·∫Ω ---
function drawStar(ctx, x, y, radius, points) {
  ctx.beginPath();
  for (let i = 0; i < 2 * points; i++) {
    let angle = Math.PI * i / points;
    let r = (i % 2 === 0) ? radius : radius / 2;
    ctx.lineTo(x + r * Math.cos(angle), y + r * Math.sin(angle));
  }
  ctx.closePath();
  ctx.fill();
}

function drawHeart(ctx, x, y, size) {
  ctx.beginPath();
  const curveFactor = 0.3; // ƒêi·ªÅu ch·ªânh ƒë·ªô cong c·ªßa tr√°i tim

  ctx.moveTo(x, y + size * curveFactor);
  ctx.bezierCurveTo(
    x + size * 0.5, y - size * 0.5,
    x + size, y + size * curveFactor,
    x, y + size * 0.9
  );
  ctx.bezierCurveTo(
    x - size, y + size * curveFactor,
    x - size * 0.5, y - size * 0.5,
    x, y + size * curveFactor
  );
  ctx.closePath();
  ctx.fill();
}

/**
 * Draws a stylized paper crane.
 * @param {CanvasRenderingContext2D} ctx - The canvas rendering context.
 * @param {number} x - The X coordinate of the crane's reference point (e.g., tail tip).
 * @param {number} y - The Y coordinate of the crane's reference point (e.g., tail tip).
 * @param {number} size - The overall size factor of the crane.
 */
function drawPaperCrane(ctx, x, y, size) {
    ctx.beginPath();
    // Start from the tail tip
    ctx.moveTo(x, y);
    // Left wing
    ctx.lineTo(x - size * 0.4, y - size * 0.2);
    ctx.lineTo(x - size * 0.8, y - size * 0.1);
    // Body left side to neck
    ctx.lineTo(x - size * 0.4, y - size * 0.4);
    ctx.lineTo(x - size * 0.2, y - size * 0.6);
    // Head and neck
    ctx.lineTo(x, y - size * 0.8); // Head tip (beak)
    ctx.lineTo(x + size * 0.2, y - size * 0.6); // Neck base right
    // Body right side to wing
    ctx.lineTo(x + size * 0.4, y - size * 0.4);
    ctx.lineTo(x + size * 0.8, y - size * 0.1); // Wing right tip
    ctx.lineTo(x + size * 0.4, y - size * 0.2); // Wing right base
    ctx.closePath();
    ctx.fill();
}


// --- L·ªõp ƒë·ªëi t∆∞·ª£ng c∆° b·∫£n ---
class BaseObject {
    constructor(x, y, color, speedX, speedY, alpha, decay, size) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.speedX = speedX;
        this.speedY = speedY;
        this.alpha = alpha;
        this.decay = decay;
        this.size = size;
    }

    update() {
        this.x += this.speedX;
        this.y += this.speedY;
        this.alpha -= this.decay;
    }

    isDead() {
        return this.alpha <= 0.05;
    }
}

// --- L·ªõp h·∫°t (Particle) ---
class Particle extends BaseObject {
    constructor(x, y, color, size = Math.random() * 1.5 + 0.5, speedX = (Math.random() - 0.5) * 1.5, speedY = Math.random() * -5 - 2, alpha = 1, decay = Math.random() * 0.04 + 0.015) {
        super(x, y, color, speedX, speedY, alpha, decay, size);
    }

    update() {
        super.update();
        this.speedY += gravity;
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        ctx.beginPath();
        ctx.arc(this.x, this.y, this.size, 0, Math.PI * 2);
        ctx.closePath();
        ctx.fill();
        ctx.restore();
    }

    isDead() {
        return super.isDead() || this.y > animationCanvas.height + this.size;
    }
}

// --- L·ªõp ph√°o hoa (Firework) ---
class Firework {
    constructor(x, y, color) {
        this.x = x;
        this.y = y;
        this.color = color;
        this.particleCount = Math.floor(Math.random() * 40 + 40);
        this.exploded = false;
        this.hasTrails = Math.random() < 0.7;
        this.trail = [];
        this.speedY = Math.random() * -4 - 3; // TƒÉng t·ªëc ƒë·ªô bay l√™n m·∫°nh h∆°n
    }

    explode() {
        if (!this.exploded) {
            for (let i = 0; i < this.particleCount; i++) {
                const angle = Math.random() * Math.PI * 2;
                const speed = Math.random() * 4 + 1.5;
                const speedX = Math.cos(angle) * speed;
                const speedY = Math.sin(angle) * speed;
                particles.push(new Particle(this.x, this.y, this.color, undefined, speedX, speedY));
            }
            this.exploded = true;
        }
    }

    update() {
        if (!this.exploded) {
            this.y += this.speedY;
            if (this.hasTrails) {
                this.trail.push({ x: this.x, y: this.y });
                if (this.trail.length > 6) {
                    this.trail.shift();
                }
            }
            // TƒÉng ng∆∞·ª°ng n·ªï v√† tƒÉng x√°c su·∫•t n·ªï s·ªõm
            if (this.y < animationCanvas.height * 0.2 || Math.random() < 0.06) {
                this.explode();
            }
        }
    }

    draw() {
        if (!this.exploded) {
            if (this.hasTrails && this.trail.length > 1) {
                ctx.beginPath();
                ctx.moveTo(this.trail[0].x, this.trail[0].y);
                for (let i = 1; i < this.trail.length; i++) {
                    ctx.lineTo(this.trail[i].x, this.trail[i].y);
                }
                ctx.strokeStyle = this.color;
                ctx.lineWidth = 1.5; // TƒÉng ƒë·ªô d√†y v·ªát s√°ng ƒë·ªÉ s√°ng h∆°n
                ctx.stroke();
            }
            ctx.fillStyle = this.color;
            ctx.beginPath();
            ctx.arc(this.x, this.y, 2, 0, Math.PI * 2); // TƒÉng nh·∫π k√≠ch th∆∞·ªõc ch·∫•m ph√°o hoa bay l√™n
            ctx.closePath();
            ctx.fill();
        }
    }

    isDead() {
        return this.exploded && particles.filter(p => p.color === this.color && !p.isDead()).length === 0;
    }
}

// --- L·ªõp ng√¥i sao (Star) ---
class Star extends BaseObject {
    constructor() {
        const x = Math.random() * animationCanvas.width;
        const y = -Math.random() * animationCanvas.height;
        const size = Math.random() * 6 + 3;
        const speed = Math.random() * 1.5 + 0.3;
        const color = starColors[Math.floor(Math.random() * starColors.length)];
        const alpha = Math.random() * 0.6 + 0.4;
        super(x, y, color, 0, speed, alpha, 0, size);
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = Math.random() * 0.05 - 0.025;
    }

    update() {
        super.update();
        this.rotation += this.rotationSpeed;
        if (this.y > animationCanvas.height + this.size) {
            this.y = -this.size;
            this.x = Math.random() * animationCanvas.width;
            this.alpha = Math.random() * 0.6 + 0.4;
            this.speedY = Math.random() * 1.5 + 0.3;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        drawStar(ctx, 0, 0, this.size / 2, 5);
        ctx.restore();
    }

    isDead() {
        return false;
    }
}

// --- L·ªõp tr√°i tim (Heart) ---
class Heart extends BaseObject {
    constructor() {
        const x = Math.random() * animationCanvas.width;
        const y = -Math.random() * animationCanvas.height;
        const size = Math.random() * 15 + 8;
        const speed = Math.random() * 1 + 0.3;
        const alpha = Math.random() * 0.7 + 0.3;
        super(x, y, heartColor, 0, speed, alpha, 0, size);
        this.rotation = Math.random() * Math.PI * 2;
        this.rotationSpeed = Math.random() * 0.05 - 0.025;
    }

    update() {
        super.update();
        this.rotation += this.rotationSpeed;
        if (this.y > animationCanvas.height + this.size) {
            this.y = -this.size;
            this.x = Math.random() * animationCanvas.width;
            this.alpha = Math.random() * 0.7 + 0.3;
            this.speedY = Math.random() * 1 + 0.3;
        }
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y);
        ctx.rotate(this.rotation);
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;
        drawHeart(ctx, 0, 0, this.size); // S·ª≠ d·ª•ng h√†m drawHeart ƒë√£ ch·ªânh s·ª≠a
        ctx.restore();
    }

    isDead() {
        return false;
    }
}

// --- L·ªõp bong b√≥ng (Balloon) ---
class Balloon extends BaseObject {
    constructor(x, y, color) {
        const radius = Math.random() * 15 + 20;
        const speedY = -(Math.random() * 0.3 + 0.3);
        const speedX = (Math.random() - 0.5) * 0.2;
        const alpha = 1;
        const decay = 0.0015;
        super(x, y, color, speedX, speedY, alpha, decay, radius);
    }

    update() {
        super.update();
        this.x += Math.sin(this.y * 0.015) * 0.3;
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha;
        ctx.fillStyle = this.color;

        ctx.beginPath();
        ctx.ellipse(this.x, this.y, this.size * 0.7, this.size, 0, 0, Math.PI * 2);
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(this.x, this.y + this.size);
        ctx.lineTo(this.x - 2, this.y + this.size + 7);
        ctx.lineTo(this.x + 2, this.y + this.size + 7);
        ctx.closePath();
        ctx.fill();

        ctx.beginPath();
        ctx.moveTo(this.x, this.y + this.size + 7);
        ctx.lineTo(this.x + (Math.sin(this.y * 0.02) * 10), this.y + this.size + 30);
        ctx.strokeStyle = 'rgba(0, 0, 0, 0.7)';
        ctx.lineWidth = 0.8;
        ctx.stroke();

        ctx.restore();
    }

    isDead() {
        return super.isDead() || this.y < -this.size * 2;
    }
}

// --- L·ªõp bong b√≥ng x√† ph√≤ng (SoapBubble) ---
class SoapBubble extends BaseObject {
    constructor() {
        const radius = Math.random() * 15 + 10; // K√≠ch th∆∞·ªõc bong b√≥ng t·ª´ 10 ƒë·∫øn 25
        const x = Math.random() * animationCanvas.width;
        // B·∫Øt ƒë·∫ßu t·ª´ tr√™n m√†n h√¨nh (v·ªã tr√≠ y √¢m ƒë·ªÉ xu·∫•t hi·ªán m∆∞·ª£t m√†)
        const y = -radius;
        // T·ªëc ƒë·ªô ban ƒë·∫ßu d∆∞∆°ng ƒë·ªÉ r∆°i xu·ªëng
        const speedY = (Math.random() * 0.5 + 0.5);
        const speedX = (Math.random() - 0.5) * 0.5; // T·ªëc ƒë·ªô di chuy·ªÉn ngang nh·∫π
        const alpha = Math.random() * 0.6 + 0.4; // TƒÉng d·∫£i ƒë·ªô trong su·ªët ban ƒë·∫ßu (0.4 - 1.0)
        const decay = 0.0008; // T·ªëc ƒë·ªô m·ªù d·∫ßn ch·∫≠m
        super(x, y, 'rgba(255, 255, 255, 0)', speedX, speedY, alpha, decay, radius); // M√†u ƒë∆∞·ª£c t·∫°o trong draw
        this.oscillationOffset = Math.random() * Math.PI * 2; // Offset cho hi·ªáu ·ª©ng l·∫Øc l∆∞ ngang
        this.shapeDistortion = Math.random() * 0.07 + 0.02; // TƒÉng bi·∫øn d·∫°ng h√¨nh d·∫°ng nh·∫π
        this.rotation = Math.random() * Math.PI * 2; // G√≥c xoay ban ƒë·∫ßu
    }

    update() {
        super.update();
        // √Åp d·ª•ng tr·ªçng l·ª±c khi r∆°i xu·ªëng
        this.speedY += gravity * 0.5; // Gi·∫£m nh·∫π t√°c ƒë·ªông tr·ªçng l·ª±c ƒë·ªÉ r∆°i m·ªÅm m·∫°i h∆°n
        this.x += this.speedX + Math.sin((this.y * 0.05) + this.oscillationOffset) * 0.8; // L·∫Øc l∆∞ ngang m·∫°nh h∆°n
        this.rotation += (this.speedX * 0.02); // Th√™m xoay nh·∫π d·ª±a tr√™n t·ªëc ƒë·ªô ngang
    }

    draw() {
        ctx.save();
        ctx.globalAlpha = this.alpha; // S·ª≠ d·ª•ng alpha c·ªßa ƒë·ªëi t∆∞·ª£ng

        // L∆∞u √Ω: C√°c t·ªça ƒë·ªô trong gradient v√† arc/ellipse/highlight s·∫Ω l√† t∆∞∆°ng ƒë·ªëi
        // sau khi ctx.translate ƒë√£ d·ªãch chuy·ªÉn v·ªÅ v·ªã tr√≠ c·ªßa bong b√≥ng.
        const gradient = ctx.createRadialGradient(
            this.size * 0.2, -this.size * 0.2, this.size * 0.1, // T√¢m c·ªßa highlight (t∆∞∆°ng ƒë·ªëi v·ªõi bong b√≥ng)
            0, 0, this.size * 0.8 // T√¢m v√† b√°n k√≠nh c·ªßa gradient ch√≠nh (t∆∞∆°ng ƒë·ªëi v·ªõi bong b√≥ng)
        );

        // Th√™m c√°c ƒëi·ªÉm d·ª´ng m√†u ƒë·ªÉ t·∫°o hi·ªáu ·ª©ng √≥ng √°nh r√µ r·ªát h∆°n
        gradient.addColorStop(0, `rgba(255, 255, 255, ${this.alpha * 1.0})`); // T√¢m bong b√≥ng r·∫•t s√°ng
        gradient.addColorStop(0.15, `hsla(${180 + Math.sin(this.y * 0.03) * 80}, 100%, 85%, ${this.alpha * 0.8})`); // M√†u xanh-t√≠m nh·∫°t thay ƒë·ªïi r√µ h∆°n
        gradient.addColorStop(0.35, `hsla(${240 + Math.cos(this.y * 0.02) * 80}, 100%, 80%, ${this.alpha * 0.7})`); // M√†u t√≠m-xanh thay ƒë·ªïi r√µ h∆°n
        gradient.addColorStop(0.55, `hsla(${300 + Math.sin(this.y * 0.04) * 80}, 100%, 75%, ${this.alpha * 0.6})`); // M√†u h·ªìng-t√≠m thay ƒë·ªïi r√µ h∆°n
        gradient.addColorStop(0.75, `hsla(${0 + Math.cos(this.y * 0.03) * 80}, 100%, 70%, ${this.alpha * 0.5})`); // M√†u cam-ƒë·ªè thay ƒë·ªïi r√µ h∆°n
        gradient.addColorStop(1, `rgba(255, 255, 255, ${this.alpha * 0.2})`); // Ngo·∫°i vi trong su·ªët h∆°n m·ªôt ch√∫t

        ctx.fillStyle = gradient;

        // √Åp d·ª•ng bi·∫øn d·∫°ng v√† xoay
        ctx.translate(this.x, this.y); // D·ªãch chuy·ªÉn context ƒë·∫øn v·ªã tr√≠ c·ªßa bong b√≥ng
        ctx.rotate(this.rotation); // Xoay context theo g√≥c quay c·ªßa bong b√≥ng
        ctx.beginPath();
        ctx.ellipse(
            0, // V·ªã tr√≠ x t∆∞∆°ng ƒë·ªëi sau khi d·ªãch chuy·ªÉn (nghƒ©a l√† t·∫°i t√¢m c·ªßa bong b√≥ng)
            0, // V·ªã tr√≠ y t∆∞∆°ng ƒë·ªëi sau khi d·ªãch chuy·ªÉn (nghƒ©a l√† t·∫°i t√¢m c·ªßa bong b√≥ng)
            this.size * (1 + Math.sin(this.y * 0.01 + this.oscillationOffset) * this.shapeDistortion), // Thay ƒë·ªïi chi·ªÅu r·ªông nh·∫π
            this.size * (1 - Math.cos(this.y * 0.01 + this.oscillationOffset) * this.shapeDistortion), // Thay ƒë·ªïi chi·ªÅu cao nh·∫π
            0, // G√≥c xoay ƒë√£ √°p d·ª•ng b·∫±ng ctx.rotate, n√™n ·ªü ƒë√¢y l√† 0
            0,
            Math.PI * 2
        );
        ctx.fill();

        // Th√™m ƒë∆∞·ªùng vi·ªÅn m·ªèng, √≥ng √°nh h∆°n v√† s√°ng h∆°n
        ctx.strokeStyle = `rgba(255, 255, 255, ${this.alpha * 1.0})`; // Vi·ªÅn tr·∫Øng r·∫•t s√°ng
        ctx.lineWidth = 2; // ƒê·ªô d√†y vi·ªÅn tƒÉng
        ctx.beginPath();
        ctx.ellipse(
            0,
            0,
            this.size * (1 + Math.sin(this.y * 0.01 + this.oscillationOffset) * this.shapeDistortion),
            this.size * (1 - Math.cos(this.y * 0.01 + this.oscillationOffset) * this.shapeDistortion),
            0,
            0,
            Math.PI * 2
        );
        ctx.stroke();

        // Th√™m m·ªôt highlight l·ªõn h∆°n v√† m·ªôt highlight nh·ªè h∆°n tr√™n b·ªÅ m·∫∑t
        if (this.alpha > 0.3) { // Ch·ªâ v·∫Ω highlight khi bong b√≥ng c√≤n ƒë·ªß r√µ
            // Highlight l·ªõn v√† s√°ng h∆°n
            ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha * 0.95})`; // R·∫•t s√°ng
            ctx.beginPath();
            ctx.arc(this.size * 0.35, -this.size * 0.35, this.size * 0.15, 0, Math.PI * 2); // V·ªã tr√≠ highlight t∆∞∆°ng ƒë·ªëi, k√≠ch th∆∞·ªõc l·ªõn h∆°n
            ctx.fill();

            // Highlight nh·ªè, m·ªù h∆°n m·ªôt ch√∫t
            ctx.fillStyle = `rgba(255, 255, 255, ${this.alpha * 0.75})`; // S√°ng v·ª´a
            ctx.beginPath();
            ctx.arc(-this.size * 0.3, -this.size * 0.5, this.size * 0.08, 0, Math.PI * 2); // V·ªã tr√≠ highlight t∆∞∆°ng ƒë·ªëi, k√≠ch th∆∞·ªõc nh·ªè h∆°n
            ctx.fill();
        }

        ctx.restore();
    }

    isDead() {
        // Bong b√≥ng b·ªã lo·∫°i b·ªè khi r∆°i ra kh·ªèi m√†n h√¨nh ph√≠a d∆∞·ªõi
        return super.isDead() || this.y > animationCanvas.height + this.size;
    }
}

// --- L·ªõp h·∫°c gi·∫•y (PaperCrane) ---
class PaperCrane extends BaseObject {
    constructor() {
        const x = Math.random() * animationCanvas.width;
        const y = -Math.random() * 50; // B·∫Øt ƒë·∫ßu h∆°i ph√≠a tr√™n m√†n h√¨nh
        const size = Math.random() * 15 + 10; // K√≠ch th∆∞·ªõc h·∫°c gi·∫•y t·ª´ 10 ƒë·∫øn 25
        const speedX = (Math.random() - 0.5) * 1; // Di chuy·ªÉn ngang ng·∫´u nhi√™n
        const speedY = Math.random() * 0.8 + 0.5; // T·ªëc ƒë·ªô r∆°i nh·∫π
        const alpha = 1;
        const decay = 0.003; // M·ªù d·∫ßn ch·∫≠m
        const randomColor = `hsl(${Math.random() * 360}, 100%, 70%)`; // M√†u HSL r·ª±c r·ª°

        super(x, y, randomColor, speedX, speedY, alpha, decay, size);
        this.rotation = Math.random() * Math.PI * 2; // G√≥c xoay ban ƒë·∫ßu
        this.rotationSpeed = (Math.random() - 0.5) * 0.05; // T·ªëc ƒë·ªô xoay ng·∫´u nhi√™n
        this.oscillationOffset = Math.random() * Math.PI * 2; // Offset cho hi·ªáu ·ª©ng l·∫Øc l∆∞ ngang
    }

    update() {
        super.update();
        this.speedY += gravity * 0.1; // Ch·ªãu ·∫£nh h∆∞·ªüng r·∫•t nh·∫π c·ªßa tr·ªçng l·ª±c
        this.rotation += this.rotationSpeed; // C·∫≠p nh·∫≠t g√≥c xoay
        this.x += Math.sin((this.y * 0.02) + this.oscillationOffset) * 0.5; // L·∫Øc l∆∞ ngang khi bay xu·ªëng
    }

    draw() {
        ctx.save();
        ctx.translate(this.x, this.y); // D·ªãch chuy·ªÉn ƒë·∫øn v·ªã tr√≠ c·ªßa h·∫°c gi·∫•y
        ctx.rotate(this.rotation); // Xoay h·∫°c gi·∫•y
        ctx.globalAlpha = this.alpha; // ƒê·∫∑t ƒë·ªô trong su·ªët
        ctx.fillStyle = this.color; // ƒê·∫∑t m√†u t√¥
        drawPaperCrane(ctx, 0, 0, this.size); // V·∫Ω h·∫°c gi·∫•y v·ªõi t√¢m ·ªü 0,0
        ctx.restore();
    }

    isDead() {
        // H·∫°c gi·∫•y b·ªã lo·∫°i b·ªè khi r∆°i ra kh·ªèi m√†n h√¨nh ph√≠a d∆∞·ªõi ho·∫∑c m·ªù ho√†n to√†n
        return super.isDead() || this.y > animationCanvas.height + this.size;
    }
}


// --- H√†m ho·∫°t ·∫£nh ch√≠nh ---
function animate() {
    ctx.clearRect(0, 0, animationCanvas.width, animationCanvas.height);

    // C·∫≠p nh·∫≠t v√† v·∫Ω ph√°o hoa
    if (Math.random() < 0.1 && fireworks.length < 25) {
        const x = Math.random() * animationCanvas.width;
        const y = animationCanvas.height + 20;
        const color = fireworkColors[Math.floor(Math.random() * fireworkColors.length)];
        fireworks.push(new Firework(x, y, color));
    }
    for (let i = fireworks.length - 1; i >= 0; i--) {
        fireworks[i].update();
        fireworks[i].draw();
        if (fireworks[i].isDead()) {
            fireworks.splice(i, 1);
        }
    }

    // C·∫≠p nh·∫≠t v√† v·∫Ω h·∫°t ph√°o hoa
    for (let i = particles.length - 1; i >= 0; i--) {
        particles[i].update();
        particles[i].draw();
        if (particles[i].isDead()) {
            particles.splice(i, 1);
        }
    }

    // C·∫≠p nh·∫≠t v√† v·∫Ω sao
    while (stars.length < 60) {
        stars.push(new Star());
    }
    stars.forEach(star => {
        star.update();
        star.draw();
    });

    // C·∫≠p nh·∫≠t v√† v·∫Ω tr√°i tim
    while (hearts.length < 50) {
        hearts.push(new Heart());
    }
    hearts.forEach(heart => {
        heart.update();
        heart.draw();
    });

    // C·∫≠p nh·∫≠t v√† v·∫Ω bong b√≥ng bay
    if (Math.random() < 0.04 && balloons.length < 20) {
        const x = Math.random() * animationCanvas.width;
        const y = animationCanvas.height + 50;
        const color = balloonColors[Math.floor(Math.random() * balloonColors.length)];
        balloons.push(new Balloon(x, y, color));
    }
    for (let i = balloons.length - 1; i >= 0; i--) {
        balloons[i].update();
        balloons[i].draw();
        if (balloons[i].isDead()) {
            balloons.splice(i, 1);
        }
    }

    // C·∫≠p nh·∫≠t v√† v·∫Ω bong b√≥ng x√† ph√≤ng
    if (Math.random() < 0.25 && soapBubbles.length < 60) { // TƒÉng t·∫ßn su·∫•t v√† s·ªë l∆∞·ª£ng bong b√≥ng
        soapBubbles.push(new SoapBubble());
    }
    for (let i = soapBubbles.length - 1; i >= 0; i--) {
        soapBubbles[i].update();
        soapBubbles[i].draw();
        if (soapBubbles[i].isDead()) {
            soapBubbles.splice(i, 1);
        }
    }

    // C·∫≠p nh·∫≠t v√† v·∫Ω h·∫°c gi·∫•y
    if (Math.random() < 0.3 && paperCranes.length < 70) { // T·∫ßn su·∫•t t·∫°o h·∫°c gi·∫•y v√† gi·ªõi h·∫°n s·ªë l∆∞·ª£ng
        paperCranes.push(new PaperCrane());
    }
    for (let i = paperCranes.length - 1; i >= 0; i--) {
        paperCranes[i].update();
        paperCranes[i].draw();
        if (paperCranes[i].isDead()) {
            paperCranes.splice(i, 1);
        }
    }

    requestId = requestAnimationFrame(animate);
}

// --- X·ª≠ l√Ω s·ª± ki·ªán ---
function hienThiTrang2() {
    const nutBatNgo = document.getElementById("nutBatNgo");
    const trang2 = document.getElementById("trang2");
    const amThanh = document.getElementById("audioNen");

    animationCanvas = document.getElementById("animation-canvas");
    ctx = animationCanvas.getContext('2d');
    animationCanvas.width = window.innerWidth;
    animationCanvas.height = window.innerHeight;

    nutBatNgo.style.display = "none";
    trang2.style.display = "block"; /* Hi·ªÉn th·ªã ngay l·∫≠p t·ª©c nh∆∞ code g·ªëc */

    amThanh.play();
    animate();
}

window.addEventListener('load', () => {
    const nutBatNgo = document.getElementById("nutBatNgo");
    if (nutBatNgo) {
        nutBatNgo.addEventListener('click', hienThiTrang2);
    }
});

window.addEventListener('resize', () => {
    if (animationCanvas) {
        animationCanvas.width = window.innerWidth;
        animationCanvas.height = window.innerHeight;
    }
});
</script>
</body>
</html>